// @ts-nocheck
import { NextResponse } from 'next/server';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';
// Ensure fontkit optional dependency iconv-lite is available to avoid build warnings
// (pdfkit -> fontkit -> restructure expects iconv-lite). We explicitly import it so Next bundles it.
import 'iconv-lite';

interface GenerateBody {
  answers: Record<string, unknown>;
  scores: {
    organizationalHealth?: number;
    efficiencyScore?: number;
    aiReadinessScore?: number;
    overallScore?: number;
    riskLevel?: string;
    [k: string]: unknown;
  };
  options?: {
    includeRecommendations?: boolean;
    includeCharts?: boolean;
    templateStyle?: string;
    organizationName?: string;
    reportTitle?: string;
  };
}

function validate(body: any): body is GenerateBody {
  return body && typeof body === 'object' && body.answers && body.scores;
}

async function buildPdf(body: GenerateBody): Promise<Buffer> {
  // Lazy import pdfkit to keep cold starts smaller
  // pdfkit has no official TS types bundled; treat as any
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const PDFKit: any = (await import('pdfkit')).default;
  const doc: any = new PDFKit({ margin: 50, size: 'LETTER', info: { Title: body.options?.reportTitle || 'Assessment Report' } });
  const chunks: any[] = [];
  doc.on('data', (c: any) => chunks.push(c));
  const done = new Promise<Buffer>((resolve, reject) => {
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);
  });

  const org = body.options?.organizationName || 'Organization';
  const title = body.options?.reportTitle || 'Assessment Report';
  doc.fontSize(20).text(title, { align: 'center' });
  doc.moveDown(0.5).fontSize(12).fillColor('#555').text(`Generated for: ${org}`, { align: 'center' });
  doc.moveDown(1).fillColor('black');

  doc.fontSize(14).text('Summary Scores', { underline: true });
  doc.moveDown(0.4);
  Object.entries(body.scores).forEach(([k, v]) => {
    doc.fontSize(11).text(`${k}: ${v}`);
  });

  doc.moveDown(0.8).fontSize(14).text('Key Answers', { underline: true });
  doc.moveDown(0.4);
  Object.entries(body.answers).slice(0, 10).forEach(([k, v]) => {
    let val: string;
    if (v && typeof v === 'object') {
      try { val = JSON.stringify(v); } catch { val = '[object]'; }
    } else {
      val = String(v);
    }
    doc.fontSize(10).text(`${k}: ${val}`);
  });

  if (body.options?.includeRecommendations) {
    doc.addPage();
    doc.fontSize(16).text('Recommendations');
    doc.moveDown(0.5).fontSize(11).list([
      'Prioritize governance alignment for sustained improvement.',
      'Increase cross‑team collaboration metrics tracking cadence.',
      'Invest in AI readiness training for mid‑level managers.',
      'Standardize data collection to enhance efficiency analytics.'
    ], { bulletRadius: 2 });
  }

  if (body.options?.includeCharts) {
    doc.addPage();
    doc.fontSize(16).text('Charts (Placeholder)');
    doc.moveDown(0.5).fontSize(10).fillColor('#666').text('In a production build, chart images (PNG/SVG) would be rendered server‑side or pre‑generated and drawn here.');
    // Simple bar visualization placeholder
    doc.moveDown(1).fillColor('#000');
    const chartOriginX = 60;
    const chartOriginY = doc.y;
    const barW = 30; const gap = 18; const maxH = 120;
    const scoreKeys = ['organizationalHealth','efficiencyScore','aiReadinessScore','overallScore'];
    const values = scoreKeys.map(k => (Number(body.scores[k] || 0))); const maxVal = Math.max(1, ...values);
    values.forEach((val, i) => {
      const h = (val / maxVal) * maxH;
      const x = chartOriginX + i * (barW + gap);
      const y = chartOriginY + (maxH - h);
      doc.rect(x, y, barW, h).fill('#2b5cff').fillColor('#000');
      doc.fontSize(8).text(scoreKeys[i].replace(/Score/i,'').slice(0,12), x, chartOriginY + maxH + 4, { width: barW, align: 'center' });
    });
  }

  doc.addPage();
  doc.fontSize(9).fillColor('#555').text('Generated by NorthPath Assessment Platform – Confidential', { align: 'center' });
  doc.end();
  return done;
}

export async function POST(req: Request) {
  try {
    const body = await req.json();
    if (!validate(body)) {
      return NextResponse.json({ error: 'Invalid payload' }, { status: 400 });
    }
  const pdf = await buildPdf(body);
  return new NextResponse(pdf as any, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `inline; filename="assessment-report.pdf"`,
    'Content-Length': (pdf as any).length?.toString() || ''
      }
    });
  } catch (err: any) {
    console.error('PDF generation error', err);
    return NextResponse.json({ error: 'Generation failed' }, { status: 500 });
  }
}
